/*
1. Дан код:

var a = 1, b = 1, c, d;
c = ++a; alert(c);           // 2
d = b++; alert(d);           // 1
c = (2+ ++a); alert(c);      // 5
d = (2+ b++); alert(d);      // 4
alert(a);                    // 3
alert(b);                    // 3

Почему код даёт именно такие результаты?

1. Переменной с присвается значение инкрементированной переменной а (1 + 1 = 2)
2. Когда плюсики указана справа от переменной, то сперва переменной d присваивается значение переменной b, а затем происходит инкрементация b
3. Плюсики указаны слева от переменной a, поэтому сперва переменная а инкрементируется (2 + 1), а затем суммируется (2 + 3)
4. Плюсики справа, поэтому сперва суммируются значения b и 2 (d = 2 + 2), а затем инкрементируется b (2 + 1 = 3)
5. Изначально a = 1, инкрементировалось дважды (в первом и третьем примерах). В итоге a = 3
6. Изначально b = 1, инкрементировалось дважды (во втором и четвертом примерах). В итоге b = 3

2. Чему будет равен x в примере ниже?
var a = 2;
var x = 1 + (a *= 2); // (a *= 2) === (a = a * 2). Поэтому x = 5

7. Сравнить null и 0. Попробуйте объяснить результат.
0 - количество чего то конкретного, что можно посчитать. Кол-во на данный момент равно нулю.
null - это ничего. Нельзя определить кол-во ничего.
По-этому:
null < 0   // false
null > 0   // false
null == 0;   // false
При этом в спецификации указано, что если null < 0 это false, возвращаем true. 
Как я понял это сделано во избежание лишних расчетов.
По-этому:
null >= 0;   // true
*/

